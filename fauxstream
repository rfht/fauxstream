#!/bin/sh

########
# Copyright (c) 2018-2025 Thomas Frohwein <thfr@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
########

############
# TODO:
############
# - fix reverb on monitoring stream when using mic+mon mode
# - ADD OPTION TO SAVE MIC TO SEPARATE FILE (solene request)
# - add mention of $DISPLAY variable for the recording?
# - AFAIK '-preset ultrafast' is specific to libx264 and needs to be disabled
#   for use of other codecs
# - get default framerate from xrandr? same for resolution - default to desktop
#   resolution?
# - document windowname (-n) needs to be in "" if multiple words
# - document that window needs to be visible/on top
# - document that compositor has negative effect on smoothness
# - document '-m' turns on recording from mic
# - may not need as many 'thread_queue_size options, but definitely for the -f sndio inputs
# - add '-s $OUTRES' ??
# - add man page
###########

###########
# LESSONS LEARNED
###########
# - audio offset needs to be applied to the audio in the second ffmpeg,
#   right of the pipe.
# - keyframing should be every 2s and automatic scene change detection should
#   be disabled per twich, videoberg recommendations.
###########

USAGE="Usage: `basename $0` [-p preset] [-m] [-d mic_device] [-a audiooffset] [-ab audio_bitrate] [-n window_name] [-c codec] [-vb bitrate] [-r resolution] [-o offset] [-fullscreen] [-s <scale_x>:<scale_y>] [-f framerate] [-v volume_adjustment] [-vmic mic_volume] [-vmon monitor_volume] [-t threads ] [-noaudio] [-crf crf] <rtmp url>"

audiooffset=0.0
audio_bitrate=96
bufsize=
container=flv
filename=
framerate=30
fullscreen=0
gop=
heightline=
heightval=
hilopass=",lowpass=3000,highpass=200,afftdn"
mic=0
mic_device=snd/0
noaudio=0
offset=
#preset=		# don't set $preset, so that ${#preset[*]} == 0 can be used
preset_vaapi=
resolution=1280x720
scaleres=
scale_h=
scale_w=
threads=0
videocodec=libx264
video_bitrate=3500
video_device=
video_format=
video_output_fps=
volume=1.0
volume_mic=1.0
volume_mon=1.0
windowname=
widthline=
widthval=
wininfoargs=
xline=
xval=0
yline=
yval=0

if [[ $# -eq 0 ]];then
	echo $USAGE; exit 0
fi

while [[ $# -gt 0 ]]
do
	case "$1" in
		-a|-ao) audiooffset="$2"; shift;;
		-ab) audio_bitrate="$2" ; shift;;
		-b|-vb) video_bitrate="$2"; shift;;
		-c) videocodec="$2"; shift;;
		-container) container="$2"; shift;;
		-crf) crf="$2"; shift;;
		-d) mic_device="$2"; shift;;
		-f) framerate="$2"; shift;;
		-fullscreen) fullscreen=1;;
		-h) echo $USAGE; exit 0;;
		-hl) hilopass="";;
		-m) mic=1;;
		-n) windowname="$2"; shift;;
		-noaudio) noaudio=1;;
		-o) offset="$2"; shift;;
		-p) preset[${#preset[*]}]="$2"; shift;;
		-r) resolution="$2"; shift;;
		-s) scaleres="$2"; shift;;
		-t) threads="$2"; shift;;
		-v) volume="$2"; shift;;
		-vmic) volume_mic="$2"; shift;;
		-vmon) volume_mon="$2"; shift;;
		-) filename="$1"; break;;
		-?*) echo $USAGE; exit 0;;
		*) filename="$1"; break;;
	esac
	shift
done

if [[ -z "$filename" ]]; then
	echo $USAGE; exit 0
fi

for p in ${preset[@]}; do
	case "$p" in
		vaapi) preset_vaapi=1;;
		*) echo "invalid preset specified: $p"; exit 1;;
	esac
done

if [[ $preset_vaapi -eq 1 ]]; then
	videocodec=h264_vaapi
	video_device="-vaapi_device /dev/dri/renderD128"
	if [[ -n "$scaleres" ]]; then
		scale_w=$(echo $scaleres | cut -dx -f1)
		scale_h=$(echo $scaleres | cut -dx -f2)
		video_format="-vf "hwupload,scale_vaapi=w=${scale_w}:h=${scale_h}:format=nv12""
	else
		video_format="-vf "format=nv12,hwupload""
	fi
else
	if [[ -n "$scaleres" ]]; then
		scaleres="scale=${scaleres},"
	fi
	video_format="-vf "${scaleres}format=yuv420p""
	video_output_fps="-r $framerate"
fi

bufsize=`expr $video_bitrate \* 2`
gop=`expr $framerate \* 2`


sndio_device="$(sndioctl -n server.device | cut -f1 -d'(')"

echo -n "Recording geometry ("
# if -r was used
if [ $resolution != "1280x720" -a -z "$windowname" ];then
  echo -n "custom"
  # if -fullscreen was used, overwrite resolution with root window parameters (overrides -r and -o)
elif [ $fullscreen -eq 1 ]; then
  xline=`xwininfo -name "$windowname" | grep "Absolute upper-left X"`
	yline=`xwininfo -name "$windowname" | grep "Absolute upper-left Y"`
	widthline=`xwininfo -root | grep "Width:"`
	heightline=`xwininfo -root | grep "Height:"`
	xval=`echo "$xline" | cut -f 7 -d " "`
	yval=`echo "$yline" | cut -f 7 -d " "`
	# width and height need to be multiples of 2
	# in the case of fullscreen, contract by 1px (if necessary; seems unlikely to happen)
	widthval=`echo "$widthline" | cut -f 4 -d " "`
	if [[ `expr $widthval % 2` -eq 1 ]]; then
		widthval=`expr $widthval - 1`
	fi
	heightval=`echo "$heightline" | cut -f 4 -d " "`
	if [[ `expr $heightval % 2` -eq 1 ]]; then
		heightval=`expr $heightval - 1`
	fi
	resolution="${widthval}x${heightval}"
	offset="+${xval},${yval}"

  echo -n "fullscreen"
# if -n was used, overwrite resolution with window parameters (overrides -r, -o, and -fullscreen)
elif [[ -n "$windowname" ]];then
	xline=`xwininfo -name "$windowname" | grep "Absolute upper-left X"`
	yline=`xwininfo -name "$windowname" | grep "Absolute upper-left Y"`
	widthline=`xwininfo -name "$windowname" | grep "Width:"`
	heightline=`xwininfo -name "$windowname" | grep "Height:"`
	xval=`echo "$xline" | cut -f 7 -d " "`
	yval=`echo "$yline" | cut -f 7 -d " "`
	# width and height need to be multiples of 2
	# in the case of windows, expand by 1px (if necessary)
	widthval=`echo "$widthline" | cut -f 4 -d " "`
	if [[ `expr $widthval % 2` -eq 1 ]]; then
		widthval=`expr $widthval + 1`
	fi
	heightval=`echo "$heightline" | cut -f 4 -d " "`
	if [[ `expr $heightval % 2` -eq 1 ]]; then
		heightval=`expr $heightval + 1`
	fi
	resolution="${widthval}x${heightval}"
	offset="+${xval},${yval}"

  echo -n "$windowname"
else
  echo -n "default"
fi
echo "): ${resolution}${offset}\n"

# global ffmpeg options
GLOBAL="\
-hide_banner \
-loglevel error \
-threads $threads\
"

VIDEO_IN="\
-show_region 1 \
${video_device} \
-f x11grab \
-video_size $resolution \
-framerate $framerate \
-i $DISPLAY$offset\
"

VIDEO_CONV="\
${video_output_fps} \
-c:v $videocodec \
-profile:v high \
-b:v ${video_bitrate}k \
-minrate ${video_bitrate}k \
-maxrate ${video_bitrate}k \
-bufsize ${bufsize}k \
-preset ultrafast \
-tune zerolatency \
${video_format} \
-g $gop \
-keyint_min $framerate \
-x264-params no-scenecut=1\
"

MON_IN="\
-f sndio \
-i snd/mon\
"

MIC_IN="\
-f sndio \
-i "$mic_device"\
"

AUDIO_CONV="\
-c:a aac \
-b:a ${audio_bitrate}k \
-aac_coder fast\
"

AUDIOMERGE="\
[0]volume=$volume_mic,aformat=channel_layouts=stereo$hilopass[l];\
[1]volume=$volume_mon,aformat=channel_layouts=stereo[m];\
[l][m]amix=inputs=2[a]\
"

# if no mic (= no -m), only record from snd/$sndio_device.mon
#	and the only filter is aresample=async=1

if [ $noaudio -lt 1 -a $mic -lt 1 ]; then
	#only monitoring stream
	RUN="ffmpeg $GLOBAL \
    $MON_IN \
    $AUDIO_CONV -f nut pipe:1 | \
	ffmpeg $GLOBAL \
    -f nut -itsoffset $audiooffset -i pipe:0 \
		$VIDEO_IN $VIDEO_CONV -c:a copy \
    -f "${container}" \"$filename\""
elif [ $noaudio -lt 1 ]; then
	#mon + mic stream
	RUN="ffmpeg $GLOBAL \
    $MIC_IN \
		$MON_IN  \
		-filter_complex \"${AUDIOMERGE}\" -map '[a]' \
    $AUDIO_CONV -f nut pipe:1 | \
	ffmpeg $GLOBAL \
    -f nut -itsoffset $audiooffset -i pipe:0 \
		$VIDEO_IN $VIDEO_CONV -c:a copy \
    -f "${container}" \"$filename\""
else
	#no audio
	RUN="ffmpeg $GLOBAL $VIDEO_IN $VIDEO_CONV -f "${container}" \"$filename\""
fi

echo "$RUN\n"
echo "Press Ctrl+C to stop recording\n" >& 2

# XXX: Not ideal to use 'ksh -c', but easiest way to handle quoted strings
#      with whitespace. Would be preferable to find a solution to run with exec.
ksh -c "$RUN"
